/*
Spotify Web API

You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// PlayerErrorReasons * `NO_PREV_TRACK` - The command requires a previous track, but there is none in the context. * `NO_NEXT_TRACK` - The command requires a next track, but there is none in the context. * `NO_SPECIFIC_TRACK` - The requested track does not exist. * `ALREADY_PAUSED` - The command requires playback to not be paused. * `NOT_PAUSED` - The command requires playback to be paused. * `NOT_PLAYING_LOCALLY` - The command requires playback on the local device. * `NOT_PLAYING_TRACK` - The command requires that a track is currently playing. * `NOT_PLAYING_CONTEXT` - The command requires that a context is currently playing. * `ENDLESS_CONTEXT` - The shuffle command cannot be applied on an endless context. * `CONTEXT_DISALLOW` - The command could not be performed on the context. * `ALREADY_PLAYING` - The track should not be restarted if the same track and context is already playing, and there is a resume point. * `RATE_LIMITED` - The user is rate limited due to too frequent track play, also known as cat-on-the-keyboard spamming. * `REMOTE_CONTROL_DISALLOW` - The context cannot be remote-controlled. * `DEVICE_NOT_CONTROLLABLE` - Not possible to remote control the device. * `VOLUME_CONTROL_DISALLOW` - Not possible to remote control the device's volume. * `NO_ACTIVE_DEVICE` - Requires an active device and the user has none. * `PREMIUM_REQUIRED` - The request is prohibited for non-premium users. * `UNKNOWN` - Certain actions are restricted because of unknown reasons. 
type PlayerErrorReasons string

// List of PlayerErrorReasons
const (
	NO_PREV_TRACK PlayerErrorReasons = "NO_PREV_TRACK"
	NO_NEXT_TRACK PlayerErrorReasons = "NO_NEXT_TRACK"
	NO_SPECIFIC_TRACK PlayerErrorReasons = "NO_SPECIFIC_TRACK"
	ALREADY_PAUSED PlayerErrorReasons = "ALREADY_PAUSED"
	NOT_PAUSED PlayerErrorReasons = "NOT_PAUSED"
	NOT_PLAYING_LOCALLY PlayerErrorReasons = "NOT_PLAYING_LOCALLY"
	NOT_PLAYING_TRACK PlayerErrorReasons = "NOT_PLAYING_TRACK"
	NOT_PLAYING_CONTEXT PlayerErrorReasons = "NOT_PLAYING_CONTEXT"
	ENDLESS_CONTEXT PlayerErrorReasons = "ENDLESS_CONTEXT"
	CONTEXT_DISALLOW PlayerErrorReasons = "CONTEXT_DISALLOW"
	ALREADY_PLAYING PlayerErrorReasons = "ALREADY_PLAYING"
	RATE_LIMITED PlayerErrorReasons = "RATE_LIMITED"
	REMOTE_CONTROL_DISALLOW PlayerErrorReasons = "REMOTE_CONTROL_DISALLOW"
	DEVICE_NOT_CONTROLLABLE PlayerErrorReasons = "DEVICE_NOT_CONTROLLABLE"
	VOLUME_CONTROL_DISALLOW PlayerErrorReasons = "VOLUME_CONTROL_DISALLOW"
	NO_ACTIVE_DEVICE PlayerErrorReasons = "NO_ACTIVE_DEVICE"
	PREMIUM_REQUIRED PlayerErrorReasons = "PREMIUM_REQUIRED"
	UNKNOWN PlayerErrorReasons = "UNKNOWN"
)

// All allowed values of PlayerErrorReasons enum
var AllowedPlayerErrorReasonsEnumValues = []PlayerErrorReasons{
	"NO_PREV_TRACK",
	"NO_NEXT_TRACK",
	"NO_SPECIFIC_TRACK",
	"ALREADY_PAUSED",
	"NOT_PAUSED",
	"NOT_PLAYING_LOCALLY",
	"NOT_PLAYING_TRACK",
	"NOT_PLAYING_CONTEXT",
	"ENDLESS_CONTEXT",
	"CONTEXT_DISALLOW",
	"ALREADY_PLAYING",
	"RATE_LIMITED",
	"REMOTE_CONTROL_DISALLOW",
	"DEVICE_NOT_CONTROLLABLE",
	"VOLUME_CONTROL_DISALLOW",
	"NO_ACTIVE_DEVICE",
	"PREMIUM_REQUIRED",
	"UNKNOWN",
}

func (v *PlayerErrorReasons) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := PlayerErrorReasons(value)
	for _, existing := range AllowedPlayerErrorReasonsEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid PlayerErrorReasons", value)
}

// NewPlayerErrorReasonsFromValue returns a pointer to a valid PlayerErrorReasons
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewPlayerErrorReasonsFromValue(v string) (*PlayerErrorReasons, error) {
	ev := PlayerErrorReasons(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for PlayerErrorReasons: valid values are %v", v, AllowedPlayerErrorReasonsEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v PlayerErrorReasons) IsValid() bool {
	for _, existing := range AllowedPlayerErrorReasonsEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to PlayerErrorReasons value
func (v PlayerErrorReasons) Ptr() *PlayerErrorReasons {
	return &v
}

type NullablePlayerErrorReasons struct {
	value *PlayerErrorReasons
	isSet bool
}

func (v NullablePlayerErrorReasons) Get() *PlayerErrorReasons {
	return v.value
}

func (v *NullablePlayerErrorReasons) Set(val *PlayerErrorReasons) {
	v.value = val
	v.isSet = true
}

func (v NullablePlayerErrorReasons) IsSet() bool {
	return v.isSet
}

func (v *NullablePlayerErrorReasons) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullablePlayerErrorReasons(val *PlayerErrorReasons) *NullablePlayerErrorReasons {
	return &NullablePlayerErrorReasons{value: val, isSet: true}
}

func (v NullablePlayerErrorReasons) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullablePlayerErrorReasons) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

