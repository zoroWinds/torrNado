/*
Spotify Web API

You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// TracksApiService TracksApi service
type TracksApiService service

type ApiAddTracksToPlaylistRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	playlistId string
	position *int32
	uris *string
	requestBody *map[string]interface{}
}

func (r ApiAddTracksToPlaylistRequest) Position(position int32) ApiAddTracksToPlaylistRequest {
	r.position = &position
	return r
}

func (r ApiAddTracksToPlaylistRequest) Uris(uris string) ApiAddTracksToPlaylistRequest {
	r.uris = &uris
	return r
}

func (r ApiAddTracksToPlaylistRequest) RequestBody(requestBody map[string]interface{}) ApiAddTracksToPlaylistRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiAddTracksToPlaylistRequest) Execute() (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	return r.ApiService.AddTracksToPlaylistExecute(r)
}

/*
AddTracksToPlaylist Add Items to Playlist 

Add one or more items to a user's playlist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return ApiAddTracksToPlaylistRequest
*/
func (a *TracksApiService) AddTracksToPlaylist(ctx context.Context, playlistId string) ApiAddTracksToPlaylistRequest {
	return ApiAddTracksToPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return ReorderOrReplacePlaylistsTracks200Response
func (a *TracksApiService) AddTracksToPlaylistExecute(r ApiAddTracksToPlaylistRequest) (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReorderOrReplacePlaylistsTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.AddTracksToPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.position != nil {
	    parameterAddToQuery(localVarQueryParams, "position", r.position, "")
	}
	if r.uris != nil {
	    parameterAddToQuery(localVarQueryParams, "uris", r.uris, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCheckUsersSavedTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	ids *string
}

func (r ApiCheckUsersSavedTracksRequest) Ids(ids string) ApiCheckUsersSavedTracksRequest {
	r.ids = &ids
	return r
}

func (r ApiCheckUsersSavedTracksRequest) Execute() ([]bool, *http.Response, error) {
	return r.ApiService.CheckUsersSavedTracksExecute(r)
}

/*
CheckUsersSavedTracks Check User's Saved Tracks 

Check if one or more tracks is already saved in the current Spotify user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCheckUsersSavedTracksRequest
*/
func (a *TracksApiService) CheckUsersSavedTracks(ctx context.Context) ApiCheckUsersSavedTracksRequest {
	return ApiCheckUsersSavedTracksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []bool
func (a *TracksApiService) CheckUsersSavedTracksExecute(r ApiCheckUsersSavedTracksRequest) ([]bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.CheckUsersSavedTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/tracks/contains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAnAlbumsTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	id string
	market *string
	limit *int32
	offset *int32
}

func (r ApiGetAnAlbumsTracksRequest) Market(market string) ApiGetAnAlbumsTracksRequest {
	r.market = &market
	return r
}

func (r ApiGetAnAlbumsTracksRequest) Limit(limit int32) ApiGetAnAlbumsTracksRequest {
	r.limit = &limit
	return r
}

func (r ApiGetAnAlbumsTracksRequest) Offset(offset int32) ApiGetAnAlbumsTracksRequest {
	r.offset = &offset
	return r
}

func (r ApiGetAnAlbumsTracksRequest) Execute() (*PagingObject, *http.Response, error) {
	return r.ApiService.GetAnAlbumsTracksExecute(r)
}

/*
GetAnAlbumsTracks Get Album Tracks 

Get Spotify catalog information about an album’s tracks.
Optional parameters can be used to limit the number of tracks returned.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetAnAlbumsTracksRequest
*/
func (a *TracksApiService) GetAnAlbumsTracks(ctx context.Context, id string) ApiGetAnAlbumsTracksRequest {
	return ApiGetAnAlbumsTracksRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PagingObject
func (a *TracksApiService) GetAnAlbumsTracksExecute(r ApiGetAnAlbumsTracksRequest) (*PagingObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetAnAlbumsTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/albums/{id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
	    parameterAddToQuery(localVarQueryParams, "market", r.market, "")
	}
	if r.limit != nil {
	    parameterAddToQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
	    parameterAddToQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAnArtistsTopTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	id string
	market *string
}

func (r ApiGetAnArtistsTopTracksRequest) Market(market string) ApiGetAnArtistsTopTracksRequest {
	r.market = &market
	return r
}

func (r ApiGetAnArtistsTopTracksRequest) Execute() (*GetAnArtistsTopTracks200Response, *http.Response, error) {
	return r.ApiService.GetAnArtistsTopTracksExecute(r)
}

/*
GetAnArtistsTopTracks Get Artist's Top Tracks 

Get Spotify catalog information about an artist's top tracks by country.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetAnArtistsTopTracksRequest
*/
func (a *TracksApiService) GetAnArtistsTopTracks(ctx context.Context, id string) ApiGetAnArtistsTopTracksRequest {
	return ApiGetAnArtistsTopTracksRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetAnArtistsTopTracks200Response
func (a *TracksApiService) GetAnArtistsTopTracksExecute(r ApiGetAnArtistsTopTracksRequest) (*GetAnArtistsTopTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAnArtistsTopTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetAnArtistsTopTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artists/{id}/top-tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
	    parameterAddToQuery(localVarQueryParams, "market", r.market, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAudioAnalysisRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	id string
}

func (r ApiGetAudioAnalysisRequest) Execute() (*AudioAnalysisObject, *http.Response, error) {
	return r.ApiService.GetAudioAnalysisExecute(r)
}

/*
GetAudioAnalysis Get Track's Audio Analysis 

Get a low-level audio analysis for a track in the Spotify catalog. The audio analysis describes the track’s structure and musical content, including rhythm, pitch, and timbre.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetAudioAnalysisRequest
*/
func (a *TracksApiService) GetAudioAnalysis(ctx context.Context, id string) ApiGetAudioAnalysisRequest {
	return ApiGetAudioAnalysisRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AudioAnalysisObject
func (a *TracksApiService) GetAudioAnalysisExecute(r ApiGetAudioAnalysisRequest) (*AudioAnalysisObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AudioAnalysisObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetAudioAnalysis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audio-analysis/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAudioFeaturesRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	id string
}

func (r ApiGetAudioFeaturesRequest) Execute() (*AudioFeaturesObject, *http.Response, error) {
	return r.ApiService.GetAudioFeaturesExecute(r)
}

/*
GetAudioFeatures Get Track's Audio Features 

Get audio feature information for a single track identified by its unique
Spotify ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetAudioFeaturesRequest
*/
func (a *TracksApiService) GetAudioFeatures(ctx context.Context, id string) ApiGetAudioFeaturesRequest {
	return ApiGetAudioFeaturesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AudioFeaturesObject
func (a *TracksApiService) GetAudioFeaturesExecute(r ApiGetAudioFeaturesRequest) (*AudioFeaturesObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AudioFeaturesObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetAudioFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audio-features/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPlaylistsTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	playlistId string
	market *string
	fields *string
	limit *int32
	offset *int32
	additionalTypes *string
}

func (r ApiGetPlaylistsTracksRequest) Market(market string) ApiGetPlaylistsTracksRequest {
	r.market = &market
	return r
}

func (r ApiGetPlaylistsTracksRequest) Fields(fields string) ApiGetPlaylistsTracksRequest {
	r.fields = &fields
	return r
}

func (r ApiGetPlaylistsTracksRequest) Limit(limit int32) ApiGetPlaylistsTracksRequest {
	r.limit = &limit
	return r
}

func (r ApiGetPlaylistsTracksRequest) Offset(offset int32) ApiGetPlaylistsTracksRequest {
	r.offset = &offset
	return r
}

func (r ApiGetPlaylistsTracksRequest) AdditionalTypes(additionalTypes string) ApiGetPlaylistsTracksRequest {
	r.additionalTypes = &additionalTypes
	return r
}

func (r ApiGetPlaylistsTracksRequest) Execute() (*PagingObject, *http.Response, error) {
	return r.ApiService.GetPlaylistsTracksExecute(r)
}

/*
GetPlaylistsTracks Get Playlist Items 

Get full details of the items of a playlist owned by a Spotify user.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return ApiGetPlaylistsTracksRequest
*/
func (a *TracksApiService) GetPlaylistsTracks(ctx context.Context, playlistId string) ApiGetPlaylistsTracksRequest {
	return ApiGetPlaylistsTracksRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return PagingObject
func (a *TracksApiService) GetPlaylistsTracksExecute(r ApiGetPlaylistsTracksRequest) (*PagingObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetPlaylistsTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
	    parameterAddToQuery(localVarQueryParams, "market", r.market, "")
	}
	if r.fields != nil {
	    parameterAddToQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.limit != nil {
	    parameterAddToQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
	    parameterAddToQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.additionalTypes != nil {
	    parameterAddToQuery(localVarQueryParams, "additional_types", r.additionalTypes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecommendationsRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	seedArtists *string
	seedGenres *string
	seedTracks *string
	limit *int32
	market *string
	minAcousticness *float32
	maxAcousticness *float32
	targetAcousticness *float32
	minDanceability *float32
	maxDanceability *float32
	targetDanceability *float32
	minDurationMs *int32
	maxDurationMs *int32
	targetDurationMs *int32
	minEnergy *float32
	maxEnergy *float32
	targetEnergy *float32
	minInstrumentalness *float32
	maxInstrumentalness *float32
	targetInstrumentalness *float32
	minKey *int32
	maxKey *int32
	targetKey *int32
	minLiveness *float32
	maxLiveness *float32
	targetLiveness *float32
	minLoudness *float32
	maxLoudness *float32
	targetLoudness *float32
	minMode *int32
	maxMode *int32
	targetMode *int32
	minPopularity *int32
	maxPopularity *int32
	targetPopularity *int32
	minSpeechiness *float32
	maxSpeechiness *float32
	targetSpeechiness *float32
	minTempo *float32
	maxTempo *float32
	targetTempo *float32
	minTimeSignature *int32
	maxTimeSignature *int32
	targetTimeSignature *int32
	minValence *float32
	maxValence *float32
	targetValence *float32
}

func (r ApiGetRecommendationsRequest) SeedArtists(seedArtists string) ApiGetRecommendationsRequest {
	r.seedArtists = &seedArtists
	return r
}

func (r ApiGetRecommendationsRequest) SeedGenres(seedGenres string) ApiGetRecommendationsRequest {
	r.seedGenres = &seedGenres
	return r
}

func (r ApiGetRecommendationsRequest) SeedTracks(seedTracks string) ApiGetRecommendationsRequest {
	r.seedTracks = &seedTracks
	return r
}

func (r ApiGetRecommendationsRequest) Limit(limit int32) ApiGetRecommendationsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetRecommendationsRequest) Market(market string) ApiGetRecommendationsRequest {
	r.market = &market
	return r
}

func (r ApiGetRecommendationsRequest) MinAcousticness(minAcousticness float32) ApiGetRecommendationsRequest {
	r.minAcousticness = &minAcousticness
	return r
}

func (r ApiGetRecommendationsRequest) MaxAcousticness(maxAcousticness float32) ApiGetRecommendationsRequest {
	r.maxAcousticness = &maxAcousticness
	return r
}

func (r ApiGetRecommendationsRequest) TargetAcousticness(targetAcousticness float32) ApiGetRecommendationsRequest {
	r.targetAcousticness = &targetAcousticness
	return r
}

func (r ApiGetRecommendationsRequest) MinDanceability(minDanceability float32) ApiGetRecommendationsRequest {
	r.minDanceability = &minDanceability
	return r
}

func (r ApiGetRecommendationsRequest) MaxDanceability(maxDanceability float32) ApiGetRecommendationsRequest {
	r.maxDanceability = &maxDanceability
	return r
}

func (r ApiGetRecommendationsRequest) TargetDanceability(targetDanceability float32) ApiGetRecommendationsRequest {
	r.targetDanceability = &targetDanceability
	return r
}

func (r ApiGetRecommendationsRequest) MinDurationMs(minDurationMs int32) ApiGetRecommendationsRequest {
	r.minDurationMs = &minDurationMs
	return r
}

func (r ApiGetRecommendationsRequest) MaxDurationMs(maxDurationMs int32) ApiGetRecommendationsRequest {
	r.maxDurationMs = &maxDurationMs
	return r
}

func (r ApiGetRecommendationsRequest) TargetDurationMs(targetDurationMs int32) ApiGetRecommendationsRequest {
	r.targetDurationMs = &targetDurationMs
	return r
}

func (r ApiGetRecommendationsRequest) MinEnergy(minEnergy float32) ApiGetRecommendationsRequest {
	r.minEnergy = &minEnergy
	return r
}

func (r ApiGetRecommendationsRequest) MaxEnergy(maxEnergy float32) ApiGetRecommendationsRequest {
	r.maxEnergy = &maxEnergy
	return r
}

func (r ApiGetRecommendationsRequest) TargetEnergy(targetEnergy float32) ApiGetRecommendationsRequest {
	r.targetEnergy = &targetEnergy
	return r
}

func (r ApiGetRecommendationsRequest) MinInstrumentalness(minInstrumentalness float32) ApiGetRecommendationsRequest {
	r.minInstrumentalness = &minInstrumentalness
	return r
}

func (r ApiGetRecommendationsRequest) MaxInstrumentalness(maxInstrumentalness float32) ApiGetRecommendationsRequest {
	r.maxInstrumentalness = &maxInstrumentalness
	return r
}

func (r ApiGetRecommendationsRequest) TargetInstrumentalness(targetInstrumentalness float32) ApiGetRecommendationsRequest {
	r.targetInstrumentalness = &targetInstrumentalness
	return r
}

func (r ApiGetRecommendationsRequest) MinKey(minKey int32) ApiGetRecommendationsRequest {
	r.minKey = &minKey
	return r
}

func (r ApiGetRecommendationsRequest) MaxKey(maxKey int32) ApiGetRecommendationsRequest {
	r.maxKey = &maxKey
	return r
}

func (r ApiGetRecommendationsRequest) TargetKey(targetKey int32) ApiGetRecommendationsRequest {
	r.targetKey = &targetKey
	return r
}

func (r ApiGetRecommendationsRequest) MinLiveness(minLiveness float32) ApiGetRecommendationsRequest {
	r.minLiveness = &minLiveness
	return r
}

func (r ApiGetRecommendationsRequest) MaxLiveness(maxLiveness float32) ApiGetRecommendationsRequest {
	r.maxLiveness = &maxLiveness
	return r
}

func (r ApiGetRecommendationsRequest) TargetLiveness(targetLiveness float32) ApiGetRecommendationsRequest {
	r.targetLiveness = &targetLiveness
	return r
}

func (r ApiGetRecommendationsRequest) MinLoudness(minLoudness float32) ApiGetRecommendationsRequest {
	r.minLoudness = &minLoudness
	return r
}

func (r ApiGetRecommendationsRequest) MaxLoudness(maxLoudness float32) ApiGetRecommendationsRequest {
	r.maxLoudness = &maxLoudness
	return r
}

func (r ApiGetRecommendationsRequest) TargetLoudness(targetLoudness float32) ApiGetRecommendationsRequest {
	r.targetLoudness = &targetLoudness
	return r
}

func (r ApiGetRecommendationsRequest) MinMode(minMode int32) ApiGetRecommendationsRequest {
	r.minMode = &minMode
	return r
}

func (r ApiGetRecommendationsRequest) MaxMode(maxMode int32) ApiGetRecommendationsRequest {
	r.maxMode = &maxMode
	return r
}

func (r ApiGetRecommendationsRequest) TargetMode(targetMode int32) ApiGetRecommendationsRequest {
	r.targetMode = &targetMode
	return r
}

func (r ApiGetRecommendationsRequest) MinPopularity(minPopularity int32) ApiGetRecommendationsRequest {
	r.minPopularity = &minPopularity
	return r
}

func (r ApiGetRecommendationsRequest) MaxPopularity(maxPopularity int32) ApiGetRecommendationsRequest {
	r.maxPopularity = &maxPopularity
	return r
}

func (r ApiGetRecommendationsRequest) TargetPopularity(targetPopularity int32) ApiGetRecommendationsRequest {
	r.targetPopularity = &targetPopularity
	return r
}

func (r ApiGetRecommendationsRequest) MinSpeechiness(minSpeechiness float32) ApiGetRecommendationsRequest {
	r.minSpeechiness = &minSpeechiness
	return r
}

func (r ApiGetRecommendationsRequest) MaxSpeechiness(maxSpeechiness float32) ApiGetRecommendationsRequest {
	r.maxSpeechiness = &maxSpeechiness
	return r
}

func (r ApiGetRecommendationsRequest) TargetSpeechiness(targetSpeechiness float32) ApiGetRecommendationsRequest {
	r.targetSpeechiness = &targetSpeechiness
	return r
}

func (r ApiGetRecommendationsRequest) MinTempo(minTempo float32) ApiGetRecommendationsRequest {
	r.minTempo = &minTempo
	return r
}

func (r ApiGetRecommendationsRequest) MaxTempo(maxTempo float32) ApiGetRecommendationsRequest {
	r.maxTempo = &maxTempo
	return r
}

func (r ApiGetRecommendationsRequest) TargetTempo(targetTempo float32) ApiGetRecommendationsRequest {
	r.targetTempo = &targetTempo
	return r
}

func (r ApiGetRecommendationsRequest) MinTimeSignature(minTimeSignature int32) ApiGetRecommendationsRequest {
	r.minTimeSignature = &minTimeSignature
	return r
}

func (r ApiGetRecommendationsRequest) MaxTimeSignature(maxTimeSignature int32) ApiGetRecommendationsRequest {
	r.maxTimeSignature = &maxTimeSignature
	return r
}

func (r ApiGetRecommendationsRequest) TargetTimeSignature(targetTimeSignature int32) ApiGetRecommendationsRequest {
	r.targetTimeSignature = &targetTimeSignature
	return r
}

func (r ApiGetRecommendationsRequest) MinValence(minValence float32) ApiGetRecommendationsRequest {
	r.minValence = &minValence
	return r
}

func (r ApiGetRecommendationsRequest) MaxValence(maxValence float32) ApiGetRecommendationsRequest {
	r.maxValence = &maxValence
	return r
}

func (r ApiGetRecommendationsRequest) TargetValence(targetValence float32) ApiGetRecommendationsRequest {
	r.targetValence = &targetValence
	return r
}

func (r ApiGetRecommendationsRequest) Execute() (*RecommendationsObject, *http.Response, error) {
	return r.ApiService.GetRecommendationsExecute(r)
}

/*
GetRecommendations Get Recommendations 

Recommendations are generated based on the available information for a given seed entity and matched against similar artists and tracks. If there is sufficient information about the provided seeds, a list of tracks will be returned together with pool size details.

For artists and tracks that are very new or obscure there might not be enough data to generate a list of tracks.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRecommendationsRequest
*/
func (a *TracksApiService) GetRecommendations(ctx context.Context) ApiGetRecommendationsRequest {
	return ApiGetRecommendationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RecommendationsObject
func (a *TracksApiService) GetRecommendationsExecute(r ApiGetRecommendationsRequest) (*RecommendationsObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RecommendationsObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetRecommendations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recommendations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.seedArtists == nil {
		return localVarReturnValue, nil, reportError("seedArtists is required and must be specified")
	}
	if r.seedGenres == nil {
		return localVarReturnValue, nil, reportError("seedGenres is required and must be specified")
	}
	if r.seedTracks == nil {
		return localVarReturnValue, nil, reportError("seedTracks is required and must be specified")
	}

	if r.limit != nil {
	    parameterAddToQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.market != nil {
	    parameterAddToQuery(localVarQueryParams, "market", r.market, "")
	}
	parameterAddToQuery(localVarQueryParams, "seed_artists", r.seedArtists, "")
	parameterAddToQuery(localVarQueryParams, "seed_genres", r.seedGenres, "")
	parameterAddToQuery(localVarQueryParams, "seed_tracks", r.seedTracks, "")
	if r.minAcousticness != nil {
	    parameterAddToQuery(localVarQueryParams, "min_acousticness", r.minAcousticness, "")
	}
	if r.maxAcousticness != nil {
	    parameterAddToQuery(localVarQueryParams, "max_acousticness", r.maxAcousticness, "")
	}
	if r.targetAcousticness != nil {
	    parameterAddToQuery(localVarQueryParams, "target_acousticness", r.targetAcousticness, "")
	}
	if r.minDanceability != nil {
	    parameterAddToQuery(localVarQueryParams, "min_danceability", r.minDanceability, "")
	}
	if r.maxDanceability != nil {
	    parameterAddToQuery(localVarQueryParams, "max_danceability", r.maxDanceability, "")
	}
	if r.targetDanceability != nil {
	    parameterAddToQuery(localVarQueryParams, "target_danceability", r.targetDanceability, "")
	}
	if r.minDurationMs != nil {
	    parameterAddToQuery(localVarQueryParams, "min_duration_ms", r.minDurationMs, "")
	}
	if r.maxDurationMs != nil {
	    parameterAddToQuery(localVarQueryParams, "max_duration_ms", r.maxDurationMs, "")
	}
	if r.targetDurationMs != nil {
	    parameterAddToQuery(localVarQueryParams, "target_duration_ms", r.targetDurationMs, "")
	}
	if r.minEnergy != nil {
	    parameterAddToQuery(localVarQueryParams, "min_energy", r.minEnergy, "")
	}
	if r.maxEnergy != nil {
	    parameterAddToQuery(localVarQueryParams, "max_energy", r.maxEnergy, "")
	}
	if r.targetEnergy != nil {
	    parameterAddToQuery(localVarQueryParams, "target_energy", r.targetEnergy, "")
	}
	if r.minInstrumentalness != nil {
	    parameterAddToQuery(localVarQueryParams, "min_instrumentalness", r.minInstrumentalness, "")
	}
	if r.maxInstrumentalness != nil {
	    parameterAddToQuery(localVarQueryParams, "max_instrumentalness", r.maxInstrumentalness, "")
	}
	if r.targetInstrumentalness != nil {
	    parameterAddToQuery(localVarQueryParams, "target_instrumentalness", r.targetInstrumentalness, "")
	}
	if r.minKey != nil {
	    parameterAddToQuery(localVarQueryParams, "min_key", r.minKey, "")
	}
	if r.maxKey != nil {
	    parameterAddToQuery(localVarQueryParams, "max_key", r.maxKey, "")
	}
	if r.targetKey != nil {
	    parameterAddToQuery(localVarQueryParams, "target_key", r.targetKey, "")
	}
	if r.minLiveness != nil {
	    parameterAddToQuery(localVarQueryParams, "min_liveness", r.minLiveness, "")
	}
	if r.maxLiveness != nil {
	    parameterAddToQuery(localVarQueryParams, "max_liveness", r.maxLiveness, "")
	}
	if r.targetLiveness != nil {
	    parameterAddToQuery(localVarQueryParams, "target_liveness", r.targetLiveness, "")
	}
	if r.minLoudness != nil {
	    parameterAddToQuery(localVarQueryParams, "min_loudness", r.minLoudness, "")
	}
	if r.maxLoudness != nil {
	    parameterAddToQuery(localVarQueryParams, "max_loudness", r.maxLoudness, "")
	}
	if r.targetLoudness != nil {
	    parameterAddToQuery(localVarQueryParams, "target_loudness", r.targetLoudness, "")
	}
	if r.minMode != nil {
	    parameterAddToQuery(localVarQueryParams, "min_mode", r.minMode, "")
	}
	if r.maxMode != nil {
	    parameterAddToQuery(localVarQueryParams, "max_mode", r.maxMode, "")
	}
	if r.targetMode != nil {
	    parameterAddToQuery(localVarQueryParams, "target_mode", r.targetMode, "")
	}
	if r.minPopularity != nil {
	    parameterAddToQuery(localVarQueryParams, "min_popularity", r.minPopularity, "")
	}
	if r.maxPopularity != nil {
	    parameterAddToQuery(localVarQueryParams, "max_popularity", r.maxPopularity, "")
	}
	if r.targetPopularity != nil {
	    parameterAddToQuery(localVarQueryParams, "target_popularity", r.targetPopularity, "")
	}
	if r.minSpeechiness != nil {
	    parameterAddToQuery(localVarQueryParams, "min_speechiness", r.minSpeechiness, "")
	}
	if r.maxSpeechiness != nil {
	    parameterAddToQuery(localVarQueryParams, "max_speechiness", r.maxSpeechiness, "")
	}
	if r.targetSpeechiness != nil {
	    parameterAddToQuery(localVarQueryParams, "target_speechiness", r.targetSpeechiness, "")
	}
	if r.minTempo != nil {
	    parameterAddToQuery(localVarQueryParams, "min_tempo", r.minTempo, "")
	}
	if r.maxTempo != nil {
	    parameterAddToQuery(localVarQueryParams, "max_tempo", r.maxTempo, "")
	}
	if r.targetTempo != nil {
	    parameterAddToQuery(localVarQueryParams, "target_tempo", r.targetTempo, "")
	}
	if r.minTimeSignature != nil {
	    parameterAddToQuery(localVarQueryParams, "min_time_signature", r.minTimeSignature, "")
	}
	if r.maxTimeSignature != nil {
	    parameterAddToQuery(localVarQueryParams, "max_time_signature", r.maxTimeSignature, "")
	}
	if r.targetTimeSignature != nil {
	    parameterAddToQuery(localVarQueryParams, "target_time_signature", r.targetTimeSignature, "")
	}
	if r.minValence != nil {
	    parameterAddToQuery(localVarQueryParams, "min_valence", r.minValence, "")
	}
	if r.maxValence != nil {
	    parameterAddToQuery(localVarQueryParams, "max_valence", r.maxValence, "")
	}
	if r.targetValence != nil {
	    parameterAddToQuery(localVarQueryParams, "target_valence", r.targetValence, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeveralAudioFeaturesRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	ids *string
}

func (r ApiGetSeveralAudioFeaturesRequest) Ids(ids string) ApiGetSeveralAudioFeaturesRequest {
	r.ids = &ids
	return r
}

func (r ApiGetSeveralAudioFeaturesRequest) Execute() (*GetSeveralAudioFeatures200Response, *http.Response, error) {
	return r.ApiService.GetSeveralAudioFeaturesExecute(r)
}

/*
GetSeveralAudioFeatures Get Tracks' Audio Features 

Get audio features for multiple tracks based on their Spotify IDs.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSeveralAudioFeaturesRequest
*/
func (a *TracksApiService) GetSeveralAudioFeatures(ctx context.Context) ApiGetSeveralAudioFeaturesRequest {
	return ApiGetSeveralAudioFeaturesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSeveralAudioFeatures200Response
func (a *TracksApiService) GetSeveralAudioFeaturesExecute(r ApiGetSeveralAudioFeaturesRequest) (*GetSeveralAudioFeatures200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSeveralAudioFeatures200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetSeveralAudioFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audio-features"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeveralTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	ids *string
	market *string
}

func (r ApiGetSeveralTracksRequest) Ids(ids string) ApiGetSeveralTracksRequest {
	r.ids = &ids
	return r
}

func (r ApiGetSeveralTracksRequest) Market(market string) ApiGetSeveralTracksRequest {
	r.market = &market
	return r
}

func (r ApiGetSeveralTracksRequest) Execute() (*GetAnArtistsTopTracks200Response, *http.Response, error) {
	return r.ApiService.GetSeveralTracksExecute(r)
}

/*
GetSeveralTracks Get Several Tracks 

Get Spotify catalog information for multiple tracks based on their Spotify IDs.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSeveralTracksRequest
*/
func (a *TracksApiService) GetSeveralTracks(ctx context.Context) ApiGetSeveralTracksRequest {
	return ApiGetSeveralTracksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAnArtistsTopTracks200Response
func (a *TracksApiService) GetSeveralTracksExecute(r ApiGetSeveralTracksRequest) (*GetAnArtistsTopTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAnArtistsTopTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetSeveralTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	if r.market != nil {
	    parameterAddToQuery(localVarQueryParams, "market", r.market, "")
	}
	parameterAddToQuery(localVarQueryParams, "ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTrackRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	id string
	market *string
}

func (r ApiGetTrackRequest) Market(market string) ApiGetTrackRequest {
	r.market = &market
	return r
}

func (r ApiGetTrackRequest) Execute() (*TrackObject, *http.Response, error) {
	return r.ApiService.GetTrackExecute(r)
}

/*
GetTrack Get Track 

Get Spotify catalog information for a single track identified by its
unique Spotify ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetTrackRequest
*/
func (a *TracksApiService) GetTrack(ctx context.Context, id string) ApiGetTrackRequest {
	return ApiGetTrackRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TrackObject
func (a *TracksApiService) GetTrackExecute(r ApiGetTrackRequest) (*TrackObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetTrack")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
	    parameterAddToQuery(localVarQueryParams, "market", r.market, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersSavedTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	market *string
	limit *int32
	offset *int32
}

func (r ApiGetUsersSavedTracksRequest) Market(market string) ApiGetUsersSavedTracksRequest {
	r.market = &market
	return r
}

func (r ApiGetUsersSavedTracksRequest) Limit(limit int32) ApiGetUsersSavedTracksRequest {
	r.limit = &limit
	return r
}

func (r ApiGetUsersSavedTracksRequest) Offset(offset int32) ApiGetUsersSavedTracksRequest {
	r.offset = &offset
	return r
}

func (r ApiGetUsersSavedTracksRequest) Execute() (*PagingObject, *http.Response, error) {
	return r.ApiService.GetUsersSavedTracksExecute(r)
}

/*
GetUsersSavedTracks Get User's Saved Tracks 

Get a list of the songs saved in the current Spotify user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsersSavedTracksRequest
*/
func (a *TracksApiService) GetUsersSavedTracks(ctx context.Context) ApiGetUsersSavedTracksRequest {
	return ApiGetUsersSavedTracksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PagingObject
func (a *TracksApiService) GetUsersSavedTracksExecute(r ApiGetUsersSavedTracksRequest) (*PagingObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetUsersSavedTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/tracks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
	    parameterAddToQuery(localVarQueryParams, "market", r.market, "")
	}
	if r.limit != nil {
	    parameterAddToQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
	    parameterAddToQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersTopArtistsAndTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	type_ string
	timeRange *string
	limit *int32
	offset *int32
}

func (r ApiGetUsersTopArtistsAndTracksRequest) TimeRange(timeRange string) ApiGetUsersTopArtistsAndTracksRequest {
	r.timeRange = &timeRange
	return r
}

func (r ApiGetUsersTopArtistsAndTracksRequest) Limit(limit int32) ApiGetUsersTopArtistsAndTracksRequest {
	r.limit = &limit
	return r
}

func (r ApiGetUsersTopArtistsAndTracksRequest) Offset(offset int32) ApiGetUsersTopArtistsAndTracksRequest {
	r.offset = &offset
	return r
}

func (r ApiGetUsersTopArtistsAndTracksRequest) Execute() (*PagingObject, *http.Response, error) {
	return r.ApiService.GetUsersTopArtistsAndTracksExecute(r)
}

/*
GetUsersTopArtistsAndTracks Get User's Top Items 

Get the current user's top artists or tracks based on calculated affinity.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_
 @return ApiGetUsersTopArtistsAndTracksRequest
*/
func (a *TracksApiService) GetUsersTopArtistsAndTracks(ctx context.Context, type_ string) ApiGetUsersTopArtistsAndTracksRequest {
	return ApiGetUsersTopArtistsAndTracksRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return PagingObject
func (a *TracksApiService) GetUsersTopArtistsAndTracksExecute(r ApiGetUsersTopArtistsAndTracksRequest) (*PagingObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetUsersTopArtistsAndTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/top/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeRange != nil {
	    parameterAddToQuery(localVarQueryParams, "time_range", r.timeRange, "")
	}
	if r.limit != nil {
	    parameterAddToQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
	    parameterAddToQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveTracksPlaylistRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	playlistId string
	removeTracksPlaylistRequest *RemoveTracksPlaylistRequest
}

func (r ApiRemoveTracksPlaylistRequest) RemoveTracksPlaylistRequest(removeTracksPlaylistRequest RemoveTracksPlaylistRequest) ApiRemoveTracksPlaylistRequest {
	r.removeTracksPlaylistRequest = &removeTracksPlaylistRequest
	return r
}

func (r ApiRemoveTracksPlaylistRequest) Execute() (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	return r.ApiService.RemoveTracksPlaylistExecute(r)
}

/*
RemoveTracksPlaylist Remove Playlist Items 

Remove one or more items from a user's playlist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return ApiRemoveTracksPlaylistRequest
*/
func (a *TracksApiService) RemoveTracksPlaylist(ctx context.Context, playlistId string) ApiRemoveTracksPlaylistRequest {
	return ApiRemoveTracksPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return ReorderOrReplacePlaylistsTracks200Response
func (a *TracksApiService) RemoveTracksPlaylistExecute(r ApiRemoveTracksPlaylistRequest) (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReorderOrReplacePlaylistsTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.RemoveTracksPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeTracksPlaylistRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveTracksUserRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	ids *string
	requestBody *map[string]interface{}
}

func (r ApiRemoveTracksUserRequest) Ids(ids string) ApiRemoveTracksUserRequest {
	r.ids = &ids
	return r
}

func (r ApiRemoveTracksUserRequest) RequestBody(requestBody map[string]interface{}) ApiRemoveTracksUserRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiRemoveTracksUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveTracksUserExecute(r)
}

/*
RemoveTracksUser Remove User's Saved Tracks 

Remove one or more tracks from the current user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveTracksUserRequest
*/
func (a *TracksApiService) RemoveTracksUser(ctx context.Context) ApiRemoveTracksUserRequest {
	return ApiRemoveTracksUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TracksApiService) RemoveTracksUserExecute(r ApiRemoveTracksUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.RemoveTracksUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/tracks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReorderOrReplacePlaylistsTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	playlistId string
	uris *string
	requestBody *map[string]interface{}
}

func (r ApiReorderOrReplacePlaylistsTracksRequest) Uris(uris string) ApiReorderOrReplacePlaylistsTracksRequest {
	r.uris = &uris
	return r
}

func (r ApiReorderOrReplacePlaylistsTracksRequest) RequestBody(requestBody map[string]interface{}) ApiReorderOrReplacePlaylistsTracksRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiReorderOrReplacePlaylistsTracksRequest) Execute() (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	return r.ApiService.ReorderOrReplacePlaylistsTracksExecute(r)
}

/*
ReorderOrReplacePlaylistsTracks Update Playlist Items 

Either reorder or replace items in a playlist depending on the request's parameters.
To reorder items, include `range_start`, `insert_before`, `range_length` and `snapshot_id` in the request's body.
To replace items, include `uris` as either a query parameter or in the request's body.
Replacing items in a playlist will overwrite its existing items. This operation can be used for replacing or clearing items in a playlist.
<br>
**Note**: Replace and reorder are mutually exclusive operations which share the same endpoint, but have different parameters.
These operations can't be applied together in a single request.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return ApiReorderOrReplacePlaylistsTracksRequest
*/
func (a *TracksApiService) ReorderOrReplacePlaylistsTracks(ctx context.Context, playlistId string) ApiReorderOrReplacePlaylistsTracksRequest {
	return ApiReorderOrReplacePlaylistsTracksRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return ReorderOrReplacePlaylistsTracks200Response
func (a *TracksApiService) ReorderOrReplacePlaylistsTracksExecute(r ApiReorderOrReplacePlaylistsTracksRequest) (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReorderOrReplacePlaylistsTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.ReorderOrReplacePlaylistsTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.uris != nil {
	    parameterAddToQuery(localVarQueryParams, "uris", r.uris, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSaveTracksUserRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	ids *string
	requestBody *map[string]interface{}
}

func (r ApiSaveTracksUserRequest) Ids(ids string) ApiSaveTracksUserRequest {
	r.ids = &ids
	return r
}

func (r ApiSaveTracksUserRequest) RequestBody(requestBody map[string]interface{}) ApiSaveTracksUserRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSaveTracksUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.SaveTracksUserExecute(r)
}

/*
SaveTracksUser Save Tracks for Current User 

Save one or more tracks to the current user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSaveTracksUserRequest
*/
func (a *TracksApiService) SaveTracksUser(ctx context.Context) ApiSaveTracksUserRequest {
	return ApiSaveTracksUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TracksApiService) SaveTracksUserExecute(r ApiSaveTracksUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.SaveTracksUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/tracks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
